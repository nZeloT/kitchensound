// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ANALYTICSPROTOCOL_H_
#define FLATBUFFERS_GENERATED_ANALYTICSPROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

struct AnalyticsMessage;

struct PageChange;

struct PlaybackChange;

struct PlaybackSongChange;

enum class AnalyticsMessageType : uint8_t {
  NONE = 0,
  PageChange = 1,
  PlaybackChange = 2,
  PlaybackSongChange = 3,
  MIN = NONE,
  MAX = PlaybackSongChange
};

inline const AnalyticsMessageType (&EnumValuesAnalyticsMessageType())[4] {
  static const AnalyticsMessageType values[] = {
    AnalyticsMessageType::NONE,
    AnalyticsMessageType::PageChange,
    AnalyticsMessageType::PlaybackChange,
    AnalyticsMessageType::PlaybackSongChange
  };
  return values;
}

inline const char * const *EnumNamesAnalyticsMessageType() {
  static const char * const names[] = {
    "NONE",
    "PageChange",
    "PlaybackChange",
    "PlaybackSongChange",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnalyticsMessageType(AnalyticsMessageType e) {
  if (e < AnalyticsMessageType::NONE || e > AnalyticsMessageType::PlaybackSongChange) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnalyticsMessageType()[index];
}

template<typename T> struct AnalyticsMessageTypeTraits {
  static const AnalyticsMessageType enum_value = AnalyticsMessageType::NONE;
};

template<> struct AnalyticsMessageTypeTraits<PageChange> {
  static const AnalyticsMessageType enum_value = AnalyticsMessageType::PageChange;
};

template<> struct AnalyticsMessageTypeTraits<PlaybackChange> {
  static const AnalyticsMessageType enum_value = AnalyticsMessageType::PlaybackChange;
};

template<> struct AnalyticsMessageTypeTraits<PlaybackSongChange> {
  static const AnalyticsMessageType enum_value = AnalyticsMessageType::PlaybackSongChange;
};

bool VerifyAnalyticsMessageType(flatbuffers::Verifier &verifier, const void *obj, AnalyticsMessageType type);
bool VerifyAnalyticsMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Page : int8_t {
  INACTIVE = 0,
  MENU_SELECTION = 1,
  OPTIONS = 2,
  RADIO_PLAYING = 3,
  RADIO_SELECTION = 4,
  BT_PLAYING = 5,
  SNAPCAST_PLAYING = 6,
  MIN = INACTIVE,
  MAX = SNAPCAST_PLAYING
};

inline const Page (&EnumValuesPage())[7] {
  static const Page values[] = {
    Page::INACTIVE,
    Page::MENU_SELECTION,
    Page::OPTIONS,
    Page::RADIO_PLAYING,
    Page::RADIO_SELECTION,
    Page::BT_PLAYING,
    Page::SNAPCAST_PLAYING
  };
  return values;
}

inline const char * const *EnumNamesPage() {
  static const char * const names[] = {
    "INACTIVE",
    "MENU_SELECTION",
    "OPTIONS",
    "RADIO_PLAYING",
    "RADIO_SELECTION",
    "BT_PLAYING",
    "SNAPCAST_PLAYING",
    nullptr
  };
  return names;
}

inline const char *EnumNamePage(Page e) {
  if (e < Page::INACTIVE || e > Page::SNAPCAST_PLAYING) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPage()[index];
}

enum class PlaybackSource : uint8_t {
  RADIO = 0,
  BLUETOOTH = 1,
  SNAPCAST = 2,
  MIN = RADIO,
  MAX = SNAPCAST
};

inline const PlaybackSource (&EnumValuesPlaybackSource())[3] {
  static const PlaybackSource values[] = {
    PlaybackSource::RADIO,
    PlaybackSource::BLUETOOTH,
    PlaybackSource::SNAPCAST
  };
  return values;
}

inline const char * const *EnumNamesPlaybackSource() {
  static const char * const names[] = {
    "RADIO",
    "BLUETOOTH",
    "SNAPCAST",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlaybackSource(PlaybackSource e) {
  if (e < PlaybackSource::RADIO || e > PlaybackSource::SNAPCAST) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPlaybackSource()[index];
}

struct AnalyticsMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGIN = 4,
    VT_TIMESTAMP = 6,
    VT_PAYLOAD_TYPE = 8,
    VT_PAYLOAD = 10
  };
  const flatbuffers::String *origin() const {
    return GetPointer<const flatbuffers::String *>(VT_ORIGIN);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  AnalyticsMessageType payload_type() const {
    return static_cast<AnalyticsMessageType>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const PageChange *payload_as_PageChange() const {
    return payload_type() == AnalyticsMessageType::PageChange ? static_cast<const PageChange *>(payload()) : nullptr;
  }
  const PlaybackChange *payload_as_PlaybackChange() const {
    return payload_type() == AnalyticsMessageType::PlaybackChange ? static_cast<const PlaybackChange *>(payload()) : nullptr;
  }
  const PlaybackSongChange *payload_as_PlaybackSongChange() const {
    return payload_type() == AnalyticsMessageType::PlaybackSongChange ? static_cast<const PlaybackSongChange *>(payload()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE) &&
           VerifyOffsetRequired(verifier, VT_PAYLOAD) &&
           VerifyAnalyticsMessageType(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const PageChange *AnalyticsMessage::payload_as<PageChange>() const {
  return payload_as_PageChange();
}

template<> inline const PlaybackChange *AnalyticsMessage::payload_as<PlaybackChange>() const {
  return payload_as_PlaybackChange();
}

template<> inline const PlaybackSongChange *AnalyticsMessage::payload_as<PlaybackSongChange>() const {
  return payload_as_PlaybackSongChange();
}

struct AnalyticsMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_origin(flatbuffers::Offset<flatbuffers::String> origin) {
    fbb_.AddOffset(AnalyticsMessage::VT_ORIGIN, origin);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(AnalyticsMessage::VT_TIMESTAMP, timestamp, 0);
  }
  void add_payload_type(AnalyticsMessageType payload_type) {
    fbb_.AddElement<uint8_t>(AnalyticsMessage::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(AnalyticsMessage::VT_PAYLOAD, payload);
  }
  explicit AnalyticsMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnalyticsMessageBuilder &operator=(const AnalyticsMessageBuilder &);
  flatbuffers::Offset<AnalyticsMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnalyticsMessage>(end);
    fbb_.Required(o, AnalyticsMessage::VT_ORIGIN);
    fbb_.Required(o, AnalyticsMessage::VT_PAYLOAD);
    return o;
  }
};

inline flatbuffers::Offset<AnalyticsMessage> CreateAnalyticsMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> origin = 0,
    uint64_t timestamp = 0,
    AnalyticsMessageType payload_type = AnalyticsMessageType::NONE,
    flatbuffers::Offset<void> payload = 0) {
  AnalyticsMessageBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_payload(payload);
  builder_.add_origin(origin);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnalyticsMessage> CreateAnalyticsMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *origin = nullptr,
    uint64_t timestamp = 0,
    AnalyticsMessageType payload_type = AnalyticsMessageType::NONE,
    flatbuffers::Offset<void> payload = 0) {
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  return CreateAnalyticsMessage(
      _fbb,
      origin__,
      timestamp,
      payload_type,
      payload);
}

struct PageChange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGIN = 4,
    VT_DESTINATION = 6
  };
  Page origin() const {
    return static_cast<Page>(GetField<int8_t>(VT_ORIGIN, 0));
  }
  Page destination() const {
    return static_cast<Page>(GetField<int8_t>(VT_DESTINATION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ORIGIN) &&
           VerifyField<int8_t>(verifier, VT_DESTINATION) &&
           verifier.EndTable();
  }
};

struct PageChangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_origin(Page origin) {
    fbb_.AddElement<int8_t>(PageChange::VT_ORIGIN, static_cast<int8_t>(origin), 0);
  }
  void add_destination(Page destination) {
    fbb_.AddElement<int8_t>(PageChange::VT_DESTINATION, static_cast<int8_t>(destination), 0);
  }
  explicit PageChangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PageChangeBuilder &operator=(const PageChangeBuilder &);
  flatbuffers::Offset<PageChange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PageChange>(end);
    return o;
  }
};

inline flatbuffers::Offset<PageChange> CreatePageChange(
    flatbuffers::FlatBufferBuilder &_fbb,
    Page origin = Page::INACTIVE,
    Page destination = Page::INACTIVE) {
  PageChangeBuilder builder_(_fbb);
  builder_.add_destination(destination);
  builder_.add_origin(origin);
  return builder_.Finish();
}

struct PlaybackChange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STARTED = 4,
    VT_SOURCE = 6,
    VT_NAME = 8
  };
  bool started() const {
    return GetField<uint8_t>(VT_STARTED, 0) != 0;
  }
  PlaybackSource source() const {
    return static_cast<PlaybackSource>(GetField<uint8_t>(VT_SOURCE, 0));
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STARTED) &&
           VerifyField<uint8_t>(verifier, VT_SOURCE) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct PlaybackChangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_started(bool started) {
    fbb_.AddElement<uint8_t>(PlaybackChange::VT_STARTED, static_cast<uint8_t>(started), 0);
  }
  void add_source(PlaybackSource source) {
    fbb_.AddElement<uint8_t>(PlaybackChange::VT_SOURCE, static_cast<uint8_t>(source), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PlaybackChange::VT_NAME, name);
  }
  explicit PlaybackChangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlaybackChangeBuilder &operator=(const PlaybackChangeBuilder &);
  flatbuffers::Offset<PlaybackChange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlaybackChange>(end);
    fbb_.Required(o, PlaybackChange::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<PlaybackChange> CreatePlaybackChange(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool started = false,
    PlaybackSource source = PlaybackSource::RADIO,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  PlaybackChangeBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_source(source);
  builder_.add_started(started);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlaybackChange> CreatePlaybackChangeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool started = false,
    PlaybackSource source = PlaybackSource::RADIO,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreatePlaybackChange(
      _fbb,
      started,
      source,
      name__);
}

struct PlaybackSongChange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RAW_META = 4,
    VT_TITLE = 6,
    VT_ARTIST = 8,
    VT_ALBUM = 10
  };
  const flatbuffers::String *raw_meta() const {
    return GetPointer<const flatbuffers::String *>(VT_RAW_META);
  }
  const flatbuffers::String *title() const {
    return GetPointer<const flatbuffers::String *>(VT_TITLE);
  }
  const flatbuffers::String *artist() const {
    return GetPointer<const flatbuffers::String *>(VT_ARTIST);
  }
  const flatbuffers::String *album() const {
    return GetPointer<const flatbuffers::String *>(VT_ALBUM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_RAW_META) &&
           verifier.VerifyString(raw_meta()) &&
           VerifyOffset(verifier, VT_TITLE) &&
           verifier.VerifyString(title()) &&
           VerifyOffset(verifier, VT_ARTIST) &&
           verifier.VerifyString(artist()) &&
           VerifyOffset(verifier, VT_ALBUM) &&
           verifier.VerifyString(album()) &&
           verifier.EndTable();
  }
};

struct PlaybackSongChangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_raw_meta(flatbuffers::Offset<flatbuffers::String> raw_meta) {
    fbb_.AddOffset(PlaybackSongChange::VT_RAW_META, raw_meta);
  }
  void add_title(flatbuffers::Offset<flatbuffers::String> title) {
    fbb_.AddOffset(PlaybackSongChange::VT_TITLE, title);
  }
  void add_artist(flatbuffers::Offset<flatbuffers::String> artist) {
    fbb_.AddOffset(PlaybackSongChange::VT_ARTIST, artist);
  }
  void add_album(flatbuffers::Offset<flatbuffers::String> album) {
    fbb_.AddOffset(PlaybackSongChange::VT_ALBUM, album);
  }
  explicit PlaybackSongChangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlaybackSongChangeBuilder &operator=(const PlaybackSongChangeBuilder &);
  flatbuffers::Offset<PlaybackSongChange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlaybackSongChange>(end);
    fbb_.Required(o, PlaybackSongChange::VT_RAW_META);
    return o;
  }
};

inline flatbuffers::Offset<PlaybackSongChange> CreatePlaybackSongChange(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> raw_meta = 0,
    flatbuffers::Offset<flatbuffers::String> title = 0,
    flatbuffers::Offset<flatbuffers::String> artist = 0,
    flatbuffers::Offset<flatbuffers::String> album = 0) {
  PlaybackSongChangeBuilder builder_(_fbb);
  builder_.add_album(album);
  builder_.add_artist(artist);
  builder_.add_title(title);
  builder_.add_raw_meta(raw_meta);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlaybackSongChange> CreatePlaybackSongChangeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *raw_meta = nullptr,
    const char *title = nullptr,
    const char *artist = nullptr,
    const char *album = nullptr) {
  auto raw_meta__ = raw_meta ? _fbb.CreateString(raw_meta) : 0;
  auto title__ = title ? _fbb.CreateString(title) : 0;
  auto artist__ = artist ? _fbb.CreateString(artist) : 0;
  auto album__ = album ? _fbb.CreateString(album) : 0;
  return CreatePlaybackSongChange(
      _fbb,
      raw_meta__,
      title__,
      artist__,
      album__);
}

inline bool VerifyAnalyticsMessageType(flatbuffers::Verifier &verifier, const void *obj, AnalyticsMessageType type) {
  switch (type) {
    case AnalyticsMessageType::NONE: {
      return true;
    }
    case AnalyticsMessageType::PageChange: {
      auto ptr = reinterpret_cast<const PageChange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnalyticsMessageType::PlaybackChange: {
      auto ptr = reinterpret_cast<const PlaybackChange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnalyticsMessageType::PlaybackSongChange: {
      auto ptr = reinterpret_cast<const PlaybackSongChange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnalyticsMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnalyticsMessageType(
        verifier,  values->Get(i), types->GetEnum<AnalyticsMessageType>(i))) {
      return false;
    }
  }
  return true;
}

inline const AnalyticsMessage *GetAnalyticsMessage(const void *buf) {
  return flatbuffers::GetRoot<AnalyticsMessage>(buf);
}

inline const AnalyticsMessage *GetSizePrefixedAnalyticsMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<AnalyticsMessage>(buf);
}

inline bool VerifyAnalyticsMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AnalyticsMessage>(nullptr);
}

inline bool VerifySizePrefixedAnalyticsMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AnalyticsMessage>(nullptr);
}

inline void FinishAnalyticsMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<AnalyticsMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedAnalyticsMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<AnalyticsMessage> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_ANALYTICSPROTOCOL_H_
